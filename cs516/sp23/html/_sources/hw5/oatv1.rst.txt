
.. include:: course.links

.. _oatv1:

Oat Language v1
-----------------

Oat supports multiple base-types of data: ``int``, ``bool``, and ``string``,
as well as arrays of such data.  The :download:`Oat language specification
<oat.pdf>`.  contains a definition of the language syntax.  Oat concrete
syntax does not require a local variable declaration to include a type
definition, instead it uses the keyword ``var``, as shown in the example
above.  Oat mostly sticks with C or Java-like syntax, except for some quirks:
``null`` requires a type annotation, and bit-wise arithmetic operators have
their own notation (so there is no overloading).

See the file ``ast.ml`` for the OCaml representation of the abstract syntax â€”
the type ``typ`` of types is defined there, along with representations of
expressions, statements, blocks, function declarations, etc.  You should
familiarize yourself with the correspondence between the OCaml representation
and the notation used in the specification.  The ``astlib`` module defines
some helper functions for printing Oat programs and abstract syntax.

This version of Oat will not be safe: it is possible to access an array out of
bounds or to call a function with incorrectly typed arguments.  The next
version of Oat (which you will implement in a later HW) will address these issues and
add some other missing features. In particular, although the grammar gives a
syntax for function types, this version of Oat does not need to support
function pointers; these are included in anticipation of the next project.


Features
~~~~~~~~

Functions
~~~~~~~~~

Oat supports mutually-recursive, top-level functions.  Each function body
consisting of a series of imperative statements that have Java-like semantics.


A complete Oat program contains a function called ``program`` with type
``(int, string[]) -> int``, which takes command-line arguments like the C
``main`` function and is the entry-point of the executable.  The file
``runtime.c`` defines the Oat standard library, which provides a few
:ref:`universally available functions <oat-runtime>`, mostly for doing I/O and working with
strings.

Global values
~~~~~~~~~~~~~

Oat supports globally-declared variables with a limited set of initializers,
including just base values (integer and boolean constants and null) and array
literals. Unlike LLVM, Oat global initializers can't contain identifiers that
refer to other global values.

Expression forms
~~~~~~~~~~~~~~~~

Oat supports several forms of expressions, including all the usual binary and
unary operations.  Boolean values are ``true`` and ``false``. Integer values
have type ``int`` and they are 64-bits. Oat uses different syntax to
distinguish boolean logical operations ``b1 & b2`` (and) and ``b1 | b2`` (or)
from bit-wise int operations ``i1 [&] i2`` (bitwise or) and ``i1 [|] i2``
(bitwise or).  (This difference from a C-like language is necessitated by the
lack of casts and overloading.)

Arrays
~~~~~~

Oat supports arrays whose elements are all of the same type, which could be
any type, including nested arrays. Arrays are considered to be *reference
types*.  The expression ``new typ [len]`` creates a new default-initialized
array of length ``len``. In this case, ``typ`` must be either ``int`` or
``bool``.  Each element of an integer array will be set to 0, and boolean
arrays will be set false.


.. admonition:: Note

   For forward compatibility with Oat v.2,
   default-initialized arrays cannot use reference types (like ``string``
   or other arrays) as the array element type.  (In Oat v.2 ``string``
   will mean "definitely not a null" string, which is not compatible with
   default initialization.)  This means that Oat v.1 cannot support
   dynamically-sized arrays whose elements are of reference type.


Explicitly-initialized arrays have a length determined at compile time, and
are written using braces with a comma-separated enumeration of array
elements. They can appear as expressions declared inside a function, and
(unlike default-initialized arrays) may contain reference types:

.. code::

   var vec = new int[]{1, -2, 3+1, f(4)};       /* vec has length 4 */
   var strs = new string[]{"a", "b", "c"};      /* strs has length 3 */
   var matrix = new int[][]{new int[]{1, 2, 3},
                            new int[]{4, 5, 6}};  /* an array of arrays */

or as global explicitly-initialized arrays (which can only use constant values):

.. code::

   global arr = new int[]{1, 2, 3, 4};


.. admonition:: Note

   There is a distinction between explicitly-initialized arrays declared at
   the global scope and those declared locally to a function.  Global
   initialized arrays are allocated at compile time, while those local to a
   function must be allocated at run time, on the heap.  Each call to a
   function might generate a new such array.


Arrays are mutable, and they can be updated using assignment notation:
``vec[0] = 17``.  Array indices start at 0 and go through ``len - 1``, where
``len`` is the length of the array.  Oat arrays (unlike C arrays) also store a
length field to support array-bounds checks, which we will add in a future
project.  For this project, you do not have to implement bounds checking.

Arrays in Oat are represented at the LL IR level by objects of the LL type
``{i64, [0 x t]}*``, that is, an array is a *pointer* to a struct whose first
element is an ``i64`` value that is the array's length, and whose second
component is an array of elements of type ``t``.  See the translation of Oat
types into LL types via the ``cmp_ty`` function.

This array representation is similar to that used in OCaml or Java, which do
not allow "inlined" multidimensional arrays as in C.  We choose this
representation to facilitate array-bounds checking (which we will implement in
a later HW). The length information is located *before* the 0th element of the
array.  For example, the following array would be represented as a pointer to
memory as shown below:


.. code::

   int[]{11,12,13,14};

   arr --+
         |
         v
        [4][11][12][13][14]

We will exploit this array representation that includes length data in the
next assignment, when we use a type system to make it a safe language.

Left-Hand-Side Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~

As usual in imperative languages, local and global identifiers denote mutable
locations, and they can appear to the left of an assignment operation. In the
example below, the identifier ``x`` appears on both the left and right:

.. code::

   x = x + 1;

On the right-hand-side of the assignment, ``x`` is implicitly dereferenced to
obtain its value, whereas on the left-hand-side, it stands for the location
where the value of ``x`` is stored. For example, in our LLVMlite IR, each Oat
local identifier will correspond to an ``alloca``\ d value on the stack,
accessed through a pointer.

Similarly, the ``i``\ th array index denotes both the value stored in the array
and the corresponding location in memory.

.. code::

   myarr[i] = myarr[i] + 1;


In this case, ``myarr`` can be an arbitrary expression that evaluates to an
array, including function calls or an index into an array of arrays. For
example the code below shows that it is legal to index off of a function call
expression, as long as the function returns an array.

.. code::

   int[] f(int[] x, int[] y, bool b) {
     if ( b ) {
       return x;
     } else {
       return y;
     }
   }

   global x = new int[]{1, 2, 3};
   global y = new int[]{4, 5, 6};

   int program (int argc, string[] argv) {
     f(x, y, true)[0] = 17;     /* non-trivial lhs */
     var z = f(x, y, true)[0] + f(y, x, false)[0];
     return z;  /* returns the value 34 */
   }


Strings
~~~~~~~

Oat supports C-style *immutable* strings, written ``"in quotes"``.  For the
moment, the string operations are very limited and mostly provided by built-in
functions provided by the runtime system.  Strings are considered to be
reference types because they are represented by a pointer to some byte
sequence.  Therefore they cannot be used in implicitly-initialized arrays
(we'll address this infelicity in a later HW).  Note that the type ``string[]`` makes
sense in Oat v.1, and it means an array of strings, none of which is null.
The only way to get a value of such a type in Oat v.1 is as an input to the
toplevel program.


.. _oat-runtime:

Built-in Functions
~~~~~~~~~~~~~~~~~~

We now have enough infrastructure to support interesting built-in operations,
including:

  - | ``string_of_array : (int[]) -> string``
    | Assumes each ``int`` of the array is in the range 0-127 and therefore represents an ASCII character.
  - ``array_of_string : (string) -> int[]``
  - ``print_string : (string) -> void``
  - ``print_int : (int) -> void``
  - ``print_bool : (bool) -> void``

These built-in operations, along with some internal C-functions used by the
Oat runtime, are implemented in ``runtime.c``.
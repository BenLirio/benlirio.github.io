HW3: X86lite Assembler and Loader
===================================

Overview
--------
Writing machine code directly is difficult and error-prone, even using our
symbolic representation of instructions. The example factorial program in the
previous section is written as a set of instructions for an assembler, a
program that can automate much of the process for us. The primary functionality
of the assembler for the purposes of this project includes the translation of
human-readable mnemonics for instructions into machine code, and the translation
of symbolic labels that appear in the assembly program into addresses understood
by the machine.

Rather than working with a concrete syntax as in the above example, we
will use the abstract syntax defined in ``x86.ml``:

.. code:: ocaml

  [ text "fac"
       [ Subq,  [~$8; ~%Rsp]
       ; Cmpq,  [~$1; ~%Rdi]
       ; J Le,  [~$$"exit"]
       ; Movq,  [~%Rdi; Ind2 Rsp]
       ; Decq,  [~%Rdi]
       ; Callq, [~$$"fac"]
       ; Imulq, [Ind2 Rsp; ~%Rax]
       ; Addq,  [~$8; ~%Rsp]
       ; Retq,  []
       ]
  ; text "exit"
       [ Movq,  [~$1; ~%Rax]
       ; Addq,  [~$8; ~%Rsp]
       ; Retq,  []
       ]
  ; gtext "main"
       [ Movq,  [~$n; ~%Rdi]
       ; Callq, [~$$"fac"]
       ; Retq,  []
       ]
  ]

As you can see, the correspondence between the abstract syntax and the concrete
syntax is quite close.  The file ``x86.ml`` and its corresponding
interface ``x86.mli`` together provide the basic definitions for the
creating and manipulating X86lite abstract syntax -- the main types you should
be aware of are ``lbl``, ``reg``, ``operand``, ``cnd``, ``ins``,
and. Each of these corresponds fairly directly to a concept from the X86lite spec.

In addition to the instructions covered in the spec, X86lite assembly
programs can contain label declarations and data consisting of either
64-bit words or zero-terminated strings. Each label declaration also
has a visibility modifier, though these will only be used in later
projects. X86lite assembly programs are represented using the
following types defined in ``x86.ml``:

.. code:: ocaml

  type data = Asciz of string
            | Quad of imm

  type asm = Text of ins list
           | Data of data list

  type elem = { lbl: lbl; global: bool; asm: asm }

  type prog = elem list

The ``elem`` type represents a section of an assembly program beginning
with a label that contains either a list of instructions or a list of data. Each
piece of data in a data section is a 64-bit value or a string. We can access
the contents of each of these sections via offsets from their associated labels.
X86lite assembly programs are lists of labeled ``elem`` blocks.

Your goal in this homework is to translate an ``X86.prog`` into the initial
machine state that your HW2 simulator can run. While this is not the easiest
way to execute an X86lite program, it illustrates some of what the system
assembler, linker, and loader will do to the assembly your compiler will
generate in future projects.

This part of the project will involve serializing instructions and
data into ``sbyte``\ s, laying out the program in memory, resolving
labels to addresses, and initializing the machine state. We can split
this into two phases, assembling and loading. The assembler will do
most of the work, outputting an executable that the loader will use to
generate an initial machine state:

.. code:: ocaml

  type exec = { entry    : quad
              ; text_pos : quad
              ; data_pos : quad
              ; text_seg : sbyte list
              ; data_seg : sbyte list
              }

An executable contains the following fields:

- **entry:** The entry point of the program, the address in memory of
  the first instruction executed.
- **text_pos, data_pos:** The address at which the following memory
  segments should be loaded.
- **text_seg, data_seg:** The assembled code for the text and data
  sections of the assembly program, with symbolic labels resolved.

Unlike an assembly program represented as an ``X86.prog``, an object
file has a single, contiguous segment of memory containing
instructions and a single contiguous segment containing data. This is
not strictly necessary to execute the program, but real systems often
keep executable code in sections of memory that are guaranteed to be
read-only by the virtual memory system for security purposes. Also,
our executables contain neither declarations nor uses of labels. The
provided functions to convert instructions and data to ``sbyte``\ s
guarantee this invariant.

Executable File Specification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We will require very specific output from your assembler and loader. Though
programs may still execute correctly using other layouts, uniform outputs are
necessary for testing purposes.

The ``text_seg`` and ``data_seg`` fields of the executable should
consist of the serialized contents of the ``Text`` and ``Data``
sections of the assembly program in the order that they appear,
without any extra padding or extraneous ``sbyte``\ s. Use the supplied
``sbytes_of_ins`` and ``sbytes_of_data`` functions. The ``text_pos``
field must be exactly 0x400000, the lowest addressable byte in the
simulator. The ``data_pos`` field must contain the address immediately
following the end of the text segment in memory. The ``entry`` field
must contain the address of the first instruction after the label
``"main"`` in the assembly program.

The ``assemble`` function should raise an ``Undefined_symbol``
exception if it encounters a label that is not declared in the source
program, or if ``"main"`` is not declared.

Loader Specification and Memory Layout
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``load`` function should initialize a machine state given an
executable file by copying the contents of ``text_seg`` and
``data_seg`` to the load addresses specified in ``text_pos`` and
``data_pos``. It should initialize the instruction pointer to the
address in ``entry``, and the stack pointer to the highest legal
memory address of our simulator. The contents of memory at the highest
address should be the sentinel ``exit_addr``.

Tasks
~~~~~
  - Complete the implementation in the ``simulator.ml`` file some parts of which are given to you.

  - First copy and paste the implementations of all the functions which you did for hw2, including ``interp_cnd``, ``map_addr`` and ``step``.

- Fill out the ``assemble`` function in the file ``assembler.ml``,
  which creates an ``obj`` given an ``X86.prog``. First, calculate the
  address where text and data should be loaded according to the memory
  layout described above. Then, to resolve forward references to
  labels, you will need to traverse the assembly program and construct
  a **symbol table** to record the absolute address of each label
  definition you encounter. The last step is to traverse the assembly
  program a second time, outputting ``sbyte``\ s for each instruction
  and data element you encounter. You will need to use your symbol
  table to replace labels, which can occur in instruction operands or
  ``Quad`` data, with their addresses.
- Fill out the ``load`` function, which creates an initial machine
  state given an object file. You will need to create an initial
  memory and copy the segments of the object file to their specified
  load addresses. You will also have to initialize the machine
  registers, setting ``%rip`` and ``%rsp`` appropriately. Lastly, you
  will need to initialize the stack to contain the sentinel
  ``exit_addr`` described in the previous section.


Tests
~~~~~

We will grade this homework based on a suite of tests. Some of them are
available for you to look at in ``gradedtests.ml``, the rest of them we
reserve for our own cases. We will also stress-test your interpreter on
a number of "big" programs that we have developed and that you and your
classmates will develop as part of the next homework.

To help other teams debug their interpreters, you are encouraged to
share "microbenchmark" test cases by posting them to the indicated
thread on slack. These should be short (2-3 instruction) programs
that test various functional aspects of the interpreter. We will not
use these tests in our grading. You may add such test cases to the
test suite defined in ``studenttests.ml``.

X86lite Assembly Programming
--------------------------------------

For this part of the assignment, you will create (by hand) a
non-trivial X86lite assembly program to test your interpreter's
behavior and gain some experience programming in X86lite.  The
factorial program supplied with the test code is a minimal example of
what we mean by "non-trivial" -- only test cases at least this level
of difficulty can earn full credit. In particular, your program should
include:

- Non-trivial control flow: either nested loops, a recursive function,
  or something similarly complex
- At least one conditional branch.
- Some amount of arithmetic or logic.
- One or more test cases that excercise your program and test the
  correctness of the interpreter's behavior. If your program computes
  a simple answer, it can return it in ``Rax`` and you can use the
  ``program_test`` harness as in the factorial example found in
  ``gradedtests.ml``; for more complex programs you might want to use
  the ``machine_test`` function, which lets you examine the resulting
  state of the interpreter.

Some good candidates for such programs include: simple sorting or
searching algorithms (i.e. treat some chunk of memory as an array of
values to be sorted), simple arithmetic algorithms such as GCD,
recursive functions over integers or very simple data structures such
as linked lists.  If you are unsure whether the test case you'd like
to implement is sufficient, contact one of the course staff.

Your test should be a function of type ``unit -> unit`` that works in
the assertion framework (as defined in ``assert.ml``).  This test
should be supplied in ``studenttests.ml`` as the "Student-Provided test 
for your custom X86lite assembly program".  We will hand grade this
submission (and test it against our own interpreter). We will also 
use all correct submitted tests to validate all of the other projects
in the course -- the trickier your test is, the harder it will be for
other teams to pass it!

.. note::

  Unlike the "microbenchmark" tests from the previous section,
  you should not post your X86lite assembly test in the slack

Grading
-------

Submit your solution to this assignment by following the
:ref:`submission instructions <submit>`

**Projects that do not compile will receive no credit!**

Your team's grade for this project will be based on:

- 30 points for visible test cases 
- 45 points for hidden test cases which includes the following :
    - End-to-end Hard (20 points)
    - X86lite Assembly Programming (manual) (10 points)
    - Style (manual) (5 points)
    - Other Team Tests (manual) (10 points)


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HW3: X86lite Assembler and Loader &mdash; CS 516 Spring 2022</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="HW4: LLVMlite" href="../hw4/hw4-llvmlite.html" />
    <link rel="prev" title="HW2: X86lite Simulator" href="../hw2/hw2-x86sim.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> CS516: Compilers
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../syllabus.html">Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../schedule.html">Schedule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../toolchain.html">Software Toolchain </a></li>
<li class="toctree-l1"><a class="reference internal" href="../submit.html">Project Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../codestyle.html">OCaml Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw2/x86lite.html">X86lite Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw4/llvmlite.html">LLVMlite Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw5/oatv1.html">Oat Language v1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw7/oatv2.html">Oat Language v2</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../hw1/hw1-hellocaml.html">HW1: Hellocaml</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw2/hw2-x86sim.html">HW2: X86lite Simulator</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">HW3: X86lite Assembler and Loader</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#executable-file-specification">Executable File Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loader-specification-and-memory-layout">Loader Specification and Memory Layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tasks">Tasks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tests">Tests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#x86lite-assembly-programming">X86lite Assembly Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grading">Grading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../hw4/hw4-llvmlite.html">HW4: LLVMlite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw5/hw5-lexing-and-parsing.html">HW5: Lexing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw6/hw6-frontend-compilation.html">HW6: Frontend Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw7/hw7-typechecking.html">HW7: Oat v2 – Typechecking</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CS516: Compilers</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">HW3: X86lite Assembler and Loader</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="hw3-x86lite-assembler-and-loader">
<h1>HW3: X86lite Assembler and Loader<a class="headerlink" href="#hw3-x86lite-assembler-and-loader" title="Permalink to this heading"></a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>Writing machine code directly is difficult and error-prone, even using our
symbolic representation of instructions. The example factorial program in the
previous section is written as a set of instructions for an assembler, a
program that can automate much of the process for us. The primary functionality
of the assembler for the purposes of this project includes the translation of
human-readable mnemonics for instructions into machine code, and the translation
of symbolic labels that appear in the assembly program into addresses understood
by the machine.</p>
<p>Rather than working with a concrete syntax as in the above example, we
will use the abstract syntax defined in <code class="docutils literal notranslate"><span class="pre">x86.ml</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">[</span> <span class="n">text</span> <span class="s2">&quot;fac&quot;</span>
     <span class="o">[</span> <span class="nc">Subq</span><span class="o">,</span>  <span class="o">[~$</span><span class="mi">8</span><span class="o">;</span> <span class="o">~%</span><span class="nc">Rsp</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Cmpq</span><span class="o">,</span>  <span class="o">[~$</span><span class="mi">1</span><span class="o">;</span> <span class="o">~%</span><span class="nc">Rdi</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">J</span> <span class="nc">Le</span><span class="o">,</span>  <span class="o">[~$$</span><span class="s2">&quot;exit&quot;</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Movq</span><span class="o">,</span>  <span class="o">[~%</span><span class="nc">Rdi</span><span class="o">;</span> <span class="nc">Ind2</span> <span class="nc">Rsp</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Decq</span><span class="o">,</span>  <span class="o">[~%</span><span class="nc">Rdi</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Callq</span><span class="o">,</span> <span class="o">[~$$</span><span class="s2">&quot;fac&quot;</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Imulq</span><span class="o">,</span> <span class="o">[</span><span class="nc">Ind2</span> <span class="nc">Rsp</span><span class="o">;</span> <span class="o">~%</span><span class="nc">Rax</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Addq</span><span class="o">,</span>  <span class="o">[~$</span><span class="mi">8</span><span class="o">;</span> <span class="o">~%</span><span class="nc">Rsp</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Retq</span><span class="o">,</span>  <span class="bp">[]</span>
     <span class="o">]</span>
<span class="o">;</span> <span class="n">text</span> <span class="s2">&quot;exit&quot;</span>
     <span class="o">[</span> <span class="nc">Movq</span><span class="o">,</span>  <span class="o">[~$</span><span class="mi">1</span><span class="o">;</span> <span class="o">~%</span><span class="nc">Rax</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Addq</span><span class="o">,</span>  <span class="o">[~$</span><span class="mi">8</span><span class="o">;</span> <span class="o">~%</span><span class="nc">Rsp</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Retq</span><span class="o">,</span>  <span class="bp">[]</span>
     <span class="o">]</span>
<span class="o">;</span> <span class="n">gtext</span> <span class="s2">&quot;main&quot;</span>
     <span class="o">[</span> <span class="nc">Movq</span><span class="o">,</span>  <span class="o">[~$</span><span class="n">n</span><span class="o">;</span> <span class="o">~%</span><span class="nc">Rdi</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Callq</span><span class="o">,</span> <span class="o">[~$$</span><span class="s2">&quot;fac&quot;</span><span class="o">]</span>
     <span class="o">;</span> <span class="nc">Retq</span><span class="o">,</span>  <span class="bp">[]</span>
     <span class="o">]</span>
<span class="o">]</span>
</pre></div>
</div>
<p>As you can see, the correspondence between the abstract syntax and the concrete
syntax is quite close.  The file <code class="docutils literal notranslate"><span class="pre">x86.ml</span></code> and its corresponding
interface <code class="docutils literal notranslate"><span class="pre">x86.mli</span></code> together provide the basic definitions for the
creating and manipulating X86lite abstract syntax – the main types you should
be aware of are <code class="docutils literal notranslate"><span class="pre">lbl</span></code>, <code class="docutils literal notranslate"><span class="pre">reg</span></code>, <code class="docutils literal notranslate"><span class="pre">operand</span></code>, <code class="docutils literal notranslate"><span class="pre">cnd</span></code>, <code class="docutils literal notranslate"><span class="pre">ins</span></code>,
and. Each of these corresponds fairly directly to a concept from the X86lite spec.</p>
<p>In addition to the instructions covered in the spec, X86lite assembly
programs can contain label declarations and data consisting of either
64-bit words or zero-terminated strings. Each label declaration also
has a visibility modifier, though these will only be used in later
projects. X86lite assembly programs are represented using the
following types defined in <code class="docutils literal notranslate"><span class="pre">x86.ml</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">data</span> <span class="o">=</span> <span class="nc">Asciz</span> <span class="k">of</span> <span class="kt">string</span>
          <span class="o">|</span> <span class="nc">Quad</span> <span class="k">of</span> <span class="n">imm</span>

<span class="k">type</span> <span class="n">asm</span> <span class="o">=</span> <span class="nc">Text</span> <span class="k">of</span> <span class="n">ins</span> <span class="kt">list</span>
         <span class="o">|</span> <span class="nc">Data</span> <span class="k">of</span> <span class="n">data</span> <span class="kt">list</span>

<span class="k">type</span> <span class="n">elem</span> <span class="o">=</span> <span class="o">{</span> <span class="n">lbl</span><span class="o">:</span> <span class="n">lbl</span><span class="o">;</span> <span class="n">global</span><span class="o">:</span> <span class="kt">bool</span><span class="o">;</span> <span class="n">asm</span><span class="o">:</span> <span class="n">asm</span> <span class="o">}</span>

<span class="k">type</span> <span class="n">prog</span> <span class="o">=</span> <span class="n">elem</span> <span class="kt">list</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">elem</span></code> type represents a section of an assembly program beginning
with a label that contains either a list of instructions or a list of data. Each
piece of data in a data section is a 64-bit value or a string. We can access
the contents of each of these sections via offsets from their associated labels.
X86lite assembly programs are lists of labeled <code class="docutils literal notranslate"><span class="pre">elem</span></code> blocks.</p>
<p>Your goal in this homework is to translate an <code class="docutils literal notranslate"><span class="pre">X86.prog</span></code> into the initial
machine state that your HW2 simulator can run. While this is not the easiest
way to execute an X86lite program, it illustrates some of what the system
assembler, linker, and loader will do to the assembly your compiler will
generate in future projects.</p>
<p>This part of the project will involve serializing instructions and
data into <code class="docutils literal notranslate"><span class="pre">sbyte</span></code>s, laying out the program in memory, resolving
labels to addresses, and initializing the machine state. We can split
this into two phases, assembling and loading. The assembler will do
most of the work, outputting an executable that the loader will use to
generate an initial machine state:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">exec</span> <span class="o">=</span> <span class="o">{</span> <span class="n">entry</span>    <span class="o">:</span> <span class="n">quad</span>
            <span class="o">;</span> <span class="n">text_pos</span> <span class="o">:</span> <span class="n">quad</span>
            <span class="o">;</span> <span class="n">data_pos</span> <span class="o">:</span> <span class="n">quad</span>
            <span class="o">;</span> <span class="n">text_seg</span> <span class="o">:</span> <span class="n">sbyte</span> <span class="kt">list</span>
            <span class="o">;</span> <span class="n">data_seg</span> <span class="o">:</span> <span class="n">sbyte</span> <span class="kt">list</span>
            <span class="o">}</span>
</pre></div>
</div>
<p>An executable contains the following fields:</p>
<ul class="simple">
<li><p><strong>entry:</strong> The entry point of the program, the address in memory of
the first instruction executed.</p></li>
<li><p><strong>text_pos, data_pos:</strong> The address at which the following memory
segments should be loaded.</p></li>
<li><p><strong>text_seg, data_seg:</strong> The assembled code for the text and data
sections of the assembly program, with symbolic labels resolved.</p></li>
</ul>
<p>Unlike an assembly program represented as an <code class="docutils literal notranslate"><span class="pre">X86.prog</span></code>, an object
file has a single, contiguous segment of memory containing
instructions and a single contiguous segment containing data. This is
not strictly necessary to execute the program, but real systems often
keep executable code in sections of memory that are guaranteed to be
read-only by the virtual memory system for security purposes. Also,
our executables contain neither declarations nor uses of labels. The
provided functions to convert instructions and data to <code class="docutils literal notranslate"><span class="pre">sbyte</span></code>s
guarantee this invariant.</p>
<section id="executable-file-specification">
<h3>Executable File Specification<a class="headerlink" href="#executable-file-specification" title="Permalink to this heading"></a></h3>
<p>We will require very specific output from your assembler and loader. Though
programs may still execute correctly using other layouts, uniform outputs are
necessary for testing purposes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">text_seg</span></code> and <code class="docutils literal notranslate"><span class="pre">data_seg</span></code> fields of the executable should
consist of the serialized contents of the <code class="docutils literal notranslate"><span class="pre">Text</span></code> and <code class="docutils literal notranslate"><span class="pre">Data</span></code>
sections of the assembly program in the order that they appear,
without any extra padding or extraneous <code class="docutils literal notranslate"><span class="pre">sbyte</span></code>s. Use the supplied
<code class="docutils literal notranslate"><span class="pre">sbytes_of_ins</span></code> and <code class="docutils literal notranslate"><span class="pre">sbytes_of_data</span></code> functions. The <code class="docutils literal notranslate"><span class="pre">text_pos</span></code>
field must be exactly 0x400000, the lowest addressable byte in the
simulator. The <code class="docutils literal notranslate"><span class="pre">data_pos</span></code> field must contain the address immediately
following the end of the text segment in memory. The <code class="docutils literal notranslate"><span class="pre">entry</span></code> field
must contain the address of the first instruction after the label
<code class="docutils literal notranslate"><span class="pre">&quot;main&quot;</span></code> in the assembly program.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">assemble</span></code> function should raise an <code class="docutils literal notranslate"><span class="pre">Undefined_symbol</span></code>
exception if it encounters a label that is not declared in the source
program, or if <code class="docutils literal notranslate"><span class="pre">&quot;main&quot;</span></code> is not declared.</p>
</section>
<section id="loader-specification-and-memory-layout">
<h3>Loader Specification and Memory Layout<a class="headerlink" href="#loader-specification-and-memory-layout" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">load</span></code> function should initialize a machine state given an
executable file by copying the contents of <code class="docutils literal notranslate"><span class="pre">text_seg</span></code> and
<code class="docutils literal notranslate"><span class="pre">data_seg</span></code> to the load addresses specified in <code class="docutils literal notranslate"><span class="pre">text_pos</span></code> and
<code class="docutils literal notranslate"><span class="pre">data_pos</span></code>. It should initialize the instruction pointer to the
address in <code class="docutils literal notranslate"><span class="pre">entry</span></code>, and the stack pointer to the highest legal
memory address of our simulator. The contents of memory at the highest
address should be the sentinel <code class="docutils literal notranslate"><span class="pre">exit_addr</span></code>.</p>
</section>
<section id="tasks">
<h3>Tasks<a class="headerlink" href="#tasks" title="Permalink to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>Complete the implementation in the <code class="docutils literal notranslate"><span class="pre">simulator.ml</span></code> file some parts of which are given to you.</p></li>
<li><p>First copy and paste the implementations of all the functions which you did for hw2, including <code class="docutils literal notranslate"><span class="pre">interp_cnd</span></code>, <code class="docutils literal notranslate"><span class="pre">map_addr</span></code> and <code class="docutils literal notranslate"><span class="pre">step</span></code>.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>Fill out the <code class="docutils literal notranslate"><span class="pre">assemble</span></code> function in the file <code class="docutils literal notranslate"><span class="pre">assembler.ml</span></code>,
which creates an <code class="docutils literal notranslate"><span class="pre">obj</span></code> given an <code class="docutils literal notranslate"><span class="pre">X86.prog</span></code>. First, calculate the
address where text and data should be loaded according to the memory
layout described above. Then, to resolve forward references to
labels, you will need to traverse the assembly program and construct
a <strong>symbol table</strong> to record the absolute address of each label
definition you encounter. The last step is to traverse the assembly
program a second time, outputting <code class="docutils literal notranslate"><span class="pre">sbyte</span></code>s for each instruction
and data element you encounter. You will need to use your symbol
table to replace labels, which can occur in instruction operands or
<code class="docutils literal notranslate"><span class="pre">Quad</span></code> data, with their addresses.</p></li>
<li><p>Fill out the <code class="docutils literal notranslate"><span class="pre">load</span></code> function, which creates an initial machine
state given an object file. You will need to create an initial
memory and copy the segments of the object file to their specified
load addresses. You will also have to initialize the machine
registers, setting <code class="docutils literal notranslate"><span class="pre">%rip</span></code> and <code class="docutils literal notranslate"><span class="pre">%rsp</span></code> appropriately. Lastly, you
will need to initialize the stack to contain the sentinel
<code class="docutils literal notranslate"><span class="pre">exit_addr</span></code> described in the previous section.</p></li>
</ul>
</section>
<section id="tests">
<h3>Tests<a class="headerlink" href="#tests" title="Permalink to this heading"></a></h3>
<p>We will grade this homework based on a suite of tests. Some of them are
available for you to look at in <code class="docutils literal notranslate"><span class="pre">gradedtests.ml</span></code>, the rest of them we
reserve for our own cases. We will also stress-test your interpreter on
a number of “big” programs that we have developed and that you and your
classmates will develop as part of the next homework.</p>
<p>To help other teams debug their interpreters, you are encouraged to
share “microbenchmark” test cases by posting them to the indicated
thread on slack. These should be short (2-3 instruction) programs
that test various functional aspects of the interpreter. We will not
use these tests in our grading. You may add such test cases to the
test suite defined in <code class="docutils literal notranslate"><span class="pre">studenttests.ml</span></code>.</p>
</section>
</section>
<section id="x86lite-assembly-programming">
<h2>X86lite Assembly Programming<a class="headerlink" href="#x86lite-assembly-programming" title="Permalink to this heading"></a></h2>
<p>For this part of the assignment, you will create (by hand) a
non-trivial X86lite assembly program to test your interpreter’s
behavior and gain some experience programming in X86lite.  The
factorial program supplied with the test code is a minimal example of
what we mean by “non-trivial” – only test cases at least this level
of difficulty can earn full credit. In particular, your program should
include:</p>
<ul class="simple">
<li><p>Non-trivial control flow: either nested loops, a recursive function,
or something similarly complex</p></li>
<li><p>At least one conditional branch.</p></li>
<li><p>Some amount of arithmetic or logic.</p></li>
<li><p>One or more test cases that excercise your program and test the
correctness of the interpreter’s behavior. If your program computes
a simple answer, it can return it in <code class="docutils literal notranslate"><span class="pre">Rax</span></code> and you can use the
<code class="docutils literal notranslate"><span class="pre">program_test</span></code> harness as in the factorial example found in
<code class="docutils literal notranslate"><span class="pre">gradedtests.ml</span></code>; for more complex programs you might want to use
the <code class="docutils literal notranslate"><span class="pre">machine_test</span></code> function, which lets you examine the resulting
state of the interpreter.</p></li>
</ul>
<p>Some good candidates for such programs include: simple sorting or
searching algorithms (i.e. treat some chunk of memory as an array of
values to be sorted), simple arithmetic algorithms such as GCD,
recursive functions over integers or very simple data structures such
as linked lists.  If you are unsure whether the test case you’d like
to implement is sufficient, contact one of the course staff.</p>
<p>Your test should be a function of type <code class="docutils literal notranslate"><span class="pre">unit</span> <span class="pre">-&gt;</span> <span class="pre">unit</span></code> that works in
the assertion framework (as defined in <code class="docutils literal notranslate"><span class="pre">assert.ml</span></code>).  This test
should be supplied in <code class="docutils literal notranslate"><span class="pre">studenttests.ml</span></code> as the “Student-Provided test
for your custom X86lite assembly program”.  We will hand grade this
submission (and test it against our own interpreter). We will also
use all correct submitted tests to validate all of the other projects
in the course – the trickier your test is, the harder it will be for
other teams to pass it!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike the “microbenchmark” tests from the previous section,
you should not post your X86lite assembly test in the slack</p>
</div>
</section>
<section id="grading">
<h2>Grading<a class="headerlink" href="#grading" title="Permalink to this heading"></a></h2>
<p>Submit your solution to this assignment by following the
<a class="reference internal" href="../submit.html#submit"><span class="std std-ref">submission instructions</span></a></p>
<p><strong>Projects that do not compile will receive no credit!</strong></p>
<p>Your team’s grade for this project will be based on:</p>
<ul class="simple">
<li><p>30 points for visible test cases</p></li>
<li><dl class="simple">
<dt>45 points for hidden test cases which includes the following :</dt><dd><ul>
<li><p>End-to-end Hard (20 points)</p></li>
<li><p>X86lite Assembly Programming (manual) (10 points)</p></li>
<li><p>Style (manual) (5 points)</p></li>
<li><p>Other Team Tests (manual) (10 points)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../hw2/hw2-x86sim.html" class="btn btn-neutral float-left" title="HW2: X86lite Simulator" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../hw4/hw4-llvmlite.html" class="btn btn-neutral float-right" title="HW4: LLVMlite" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Eric Koskinen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>